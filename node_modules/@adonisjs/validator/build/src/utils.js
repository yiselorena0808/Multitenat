/*
 * @adonisjs/validator
 *
 * (c) AdonisJS
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { rules as schemaRules } from './rules/index.js';
import validations from './validations/index.js';
function hasRuleValidation(ruleName) {
    if (ruleName in validations) {
        return true;
    }
    return false;
}
/**
 * Compiles the `Rule` object and returns `ParsedRule` object.
 */
export function compileRule(type, subtype, rule, tree) {
    const ruleName = rule.name;
    if (!hasRuleValidation(ruleName)) {
        throw new Error(`"${rule.name}" rule is not registered. Use "validator.rule" to add the rule.`);
    }
    const ruleValidation = validations[ruleName];
    if (typeof ruleValidation.compile !== 'function') {
        throw new Error(`"${rule.name}" rule must implement the compile function`);
    }
    if (typeof ruleValidation.validate !== 'function') {
        throw new Error(`"${rule.name}" rule must implement the validate function`);
    }
    const options = ruleValidation.compile(type, subtype, rule.options, tree);
    tree[rule.name] = options.compiledOptions;
    return options;
}
/**
 * Dry function to define a literal type
 */
export function getLiteralType(subtype, optional, nullable, ruleOptions, rules) {
    const subTypeRule = rules.find((rule) => rule.name === subtype);
    const optionsTree = {};
    return {
        getTree() {
            return {
                type: 'literal',
                nullable,
                optional,
                subtype: subtype,
                rules: []
                    .concat(optional ? [] : nullable ? [schemaRules.nullable()] : [schemaRules.required()])
                    .concat(subTypeRule ? [] : [schemaRules[subtype](ruleOptions)])
                    .concat(rules)
                    .map((rule) => compileRule('literal', subtype, rule, optionsTree)),
            };
        },
    };
}
/**
 * Dry function to define an object type
 */
export function getObjectType(optional, nullable, children, rules) {
    const subTypeRule = rules.find((rule) => rule.name === 'object');
    const optionsTree = {};
    return {
        getTree() {
            return {
                type: 'object',
                nullable,
                optional,
                rules: []
                    .concat(optional ? [] : nullable ? [schemaRules.nullable()] : [schemaRules.required()])
                    .concat(subTypeRule ? [] : [{ name: 'object', options: [] }])
                    .concat(rules)
                    .map((rule) => compileRule('object', 'object', rule, optionsTree)),
                ...(children ? { children } : {}),
            };
        },
    };
}
/**
 * Dry function to define an array type
 */
export function getArrayType(optional, nullable, each, rules) {
    const subTypeRule = rules.find((rule) => rule.name === 'array');
    const optionsTree = {};
    return {
        getTree() {
            return {
                type: 'array',
                nullable,
                optional,
                rules: []
                    .concat(optional ? [] : nullable ? [schemaRules.nullable()] : [schemaRules.required()])
                    .concat(subTypeRule ? [] : [{ name: 'array', options: [] }])
                    .concat(rules)
                    .map((rule) => compileRule('array', 'array', rule, optionsTree)),
                ...(each ? { each } : {}),
            };
        },
    };
}
